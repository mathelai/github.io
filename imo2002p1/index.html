<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMO 2002 P1 Simulation</title>
    <link rel="stylesheet" href="../tokens.css">
    <link rel="stylesheet" href="../base.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
        }

        .problem-statement {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }

        .problem-statement p {
            line-height: 1.6;
            color: #555;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #333;
        }

        input[type="range"] {
            width: 200px;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        .visualization-panel {
            background: #fafafa;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e0e0e0;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        #canvas {
            border: 2px solid #667eea;
            border-radius: 5px;
            background: white;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 600;
            color: #666;
        }

        .stat-value {
            color: #333;
            font-weight: 700;
        }

        .stat-value.equal {
            color: #10b981;
        }

        .stat-value.not-equal {
            color: #ef4444;
        }

        .coloring-list {
            max-height: 400px;
            overflow-y: auto;
            background: white;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }

        .coloring-item {
            padding: 12px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .coloring-item:hover {
            background: #f9fafb;
        }

        .coloring-item.selected {
            background: #e0e7ff;
            border-left: 4px solid #667eea;
        }

        .coloring-item.counterexample {
            border-left: 4px solid #ef4444;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #333;
        }

        .simulation-info {
            grid-column: 1 / -1;
            background: #fff7ed;
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #f59e0b;
        }

        .simulation-info h3 {
            color: #92400e;
            margin-bottom: 10px;
        }

        .simulation-info p {
            color: #78350f;
            line-height: 1.6;
        }
            /* Motion preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
    <main id="main">
  <div class="container">
        <h1>IMO 2002 Problem 1</h1>

        <section aria-labelledby="problem-title">
  <div class="problem-statement">
            <p><strong>Problem:</strong> S is the set of all (h,k) with h,k non-negative integers such that h + k &lt; n.
            Each element of S is colored red or blue, so that if (h,k) is red and h' ≤ h, k' ≤ k, then (h',k') is also red.
            A <strong>type 1</strong> subset of S has n blue elements with different first member and a <strong>type 2</strong> subset
            of S has n blue elements with different second member. <strong>Show that there are the same number of type 1 and type 2 subsets.</strong></p>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="nSlider">n = <span id="nValue">3</span></label>
                <input type="range" id="nSlider" min="1" max="6" value="3" step="1">
            </div>
            <button id="runSimulation">Run Simulation</button>
            <button id="randomColoring">Random Coloring</button>
            <button id="clearColoring">Clear All</button>
        </div>

        <div class="main-content">
            <div class="visualization-panel">
                <div class="panel-title">Grid Visualization (Click to toggle points)</div>
                <canvas id="canvas" width="500" height="500" role="img" aria-label="Interactive visualization of the mathematical problem"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3b82f6;"></div>
                        <span>Blue (Allowed)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ef4444;"></div>
                        <span>Red (Forbidden)</span>
                    </div>
                </div>
                <div class="stats" role="status" aria-live="polite">
                    <div class="stat-row">
                        <span class="stat-label">Total Points in S:</span>
                        <span class="stat-value" id="totalPoints">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Blue Points:</span>
                        <span class="stat-value" id="bluePoints">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Type 1 Subsets:</span>
                        <span class="stat-value" id="type1Count">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Type 2 Subsets:</span>
                        <span class="stat-value" id="type2Count">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Equal?</span>
                        <span class="stat-value" id="equalStatus">-</span>
                    </div>
                </div>
            </div>

            <div class="visualization-panel">
                <div class="panel-title">Valid Colorings</div>
                <div id="coloringList" class="coloring-list"></div>
            </div>

            <div class="simulation-info">
                <h3>Simulation Results</h3>
                <p id="simulationResults">Click "Run Simulation" to enumerate all valid colorings and verify the conjecture.</p>
            </div>
        </div>
    </div>

    </main>
  <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const nSlider = document.getElementById('nSlider');
        const nValue = document.getElementById('nValue');

        let n = 3;
        let bluePoints = new Set();
        let validColorings = [];
        let selectedColoringIndex = null;

        // Generate all points in S
        function generateAllPoints(n) {
            const points = [];
            for (let h = 0; h < n; h++) {
                for (let k = 0; k < n - h; k++) {
                    points.push([h, k]);
                }
            }
            return points;
        }

        // Check if a coloring is valid
        function isValidColoring(blueSet, allPoints) {
            const redSet = new Set(
                allPoints.map(p => JSON.stringify(p)).filter(p => !blueSet.has(p))
            );

            for (const redStr of redSet) {
                const [h, k] = JSON.parse(redStr);
                // All points (h', k') with h' <= h and k' <= k must also be red
                for (let hp = 0; hp <= h; hp++) {
                    for (let kp = 0; kp <= k; kp++) {
                        const pointStr = JSON.stringify([hp, kp]);
                        if (blueSet.has(pointStr)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // Get type 1 subsets
        function getType1Subsets(blueSet, n) {
            const blueArray = Array.from(blueSet).map(s => JSON.parse(s));
            const byFirst = {};

            for (const [h, k] of blueArray) {
                if (!byFirst[h]) byFirst[h] = [];
                byFirst[h].push([h, k]);
            }

            const firstCoords = Object.keys(byFirst).map(Number);
            if (firstCoords.length < n) return [];

            const subsets = [];
            const combinations = getCombinations(firstCoords, n);

            for (const combo of combinations) {
                const pointChoices = combo.map(h => byFirst[h]);
                const products = cartesianProduct(pointChoices);
                subsets.push(...products);
            }

            return subsets;
        }

        // Get type 2 subsets
        function getType2Subsets(blueSet, n) {
            const blueArray = Array.from(blueSet).map(s => JSON.parse(s));
            const bySecond = {};

            for (const [h, k] of blueArray) {
                if (!bySecond[k]) bySecond[k] = [];
                bySecond[k].push([h, k]);
            }

            const secondCoords = Object.keys(bySecond).map(Number);
            if (secondCoords.length < n) return [];

            const subsets = [];
            const combinations = getCombinations(secondCoords, n);

            for (const combo of combinations) {
                const pointChoices = combo.map(k => bySecond[k]);
                const products = cartesianProduct(pointChoices);
                subsets.push(...products);
            }

            return subsets;
        }

        // Helper: get combinations
        function getCombinations(array, size) {
            if (size === 0) return [[]];
            if (array.length === 0) return [];

            const [first, ...rest] = array;
            const withoutFirst = getCombinations(rest, size);
            const withFirst = getCombinations(rest, size - 1).map(combo => [first, ...combo]);

            return [...withoutFirst, ...withFirst];
        }

        // Helper: cartesian product
        function cartesianProduct(arrays) {
            if (arrays.length === 0) return [[]];
            if (arrays.length === 1) return arrays[0].map(x => [x]);

            const [first, ...rest] = arrays;
            const restProduct = cartesianProduct(rest);
            const result = [];

            for (const item of first) {
                for (const prod of restProduct) {
                    result.push([item, ...prod]);
                }
            }

            return result;
        }

        // Enumerate all valid colorings
        function enumerateValidColorings(n) {
            const allPoints = generateAllPoints(n);
            const validColorings = [];

            // Try all possible subsets
            const totalSubsets = Math.pow(2, allPoints.length);

            for (let i = 0; i < totalSubsets; i++) {
                const blueSet = new Set();
                for (let j = 0; j < allPoints.length; j++) {
                    if (i & (1 << j)) {
                        blueSet.add(JSON.stringify(allPoints[j]));
                    }
                }

                if (isValidColoring(blueSet, allPoints)) {
                    const type1 = getType1Subsets(blueSet, n);
                    const type2 = getType2Subsets(blueSet, n);

                    validColorings.push({
                        blueSet,
                        type1Count: type1.length,
                        type2Count: type2.length,
                        equal: type1.length === type2.length
                    });
                }
            }

            return validColorings;
        }

        // Draw the grid
        function drawGrid() {
            const allPoints = generateAllPoints(n);
            const cellSize = Math.min(450 / n, 80);
            const offsetX = 50;
            const offsetY = 450;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.lineTo(offsetX + n * cellSize + 20, offsetY);
            ctx.moveTo(offsetX, offsetY);
            ctx.lineTo(offsetX, offsetY - n * cellSize - 20);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('h', offsetX + n * cellSize + 30, offsetY + 5);
            ctx.fillText('k', offsetX - 10, offsetY - n * cellSize - 25);

            // Draw points
            for (const [h, k] of allPoints) {
                const x = offsetX + h * cellSize;
                const y = offsetY - k * cellSize;

                const pointStr = JSON.stringify([h, k]);
                const isBlue = bluePoints.has(pointStr);

                // Draw circle
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, 2 * Math.PI);
                ctx.fillStyle = isBlue ? '#3b82f6' : '#ef4444';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${h},${k}`, x, y);
            }

            // Draw grid numbers
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            for (let i = 0; i < n; i++) {
                ctx.fillText(i, offsetX + i * cellSize, offsetY + 20);
                ctx.fillText(i, offsetX - 20, offsetY - i * cellSize);
            }

            updateStats();
        }

        // Update statistics
        function updateStats() {
            const allPoints = generateAllPoints(n);
            document.getElementById('totalPoints').textContent = allPoints.length;
            document.getElementById('bluePoints').textContent = bluePoints.size;

            if (isValidColoring(bluePoints, allPoints)) {
                const type1 = getType1Subsets(bluePoints, n);
                const type2 = getType2Subsets(bluePoints, n);

                document.getElementById('type1Count').textContent = type1.length;
                document.getElementById('type2Count').textContent = type2.length;

                const equalStatus = document.getElementById('equalStatus');
                if (type1.length === type2.length) {
                    equalStatus.textContent = 'Yes ✓';
                    equalStatus.className = 'stat-value equal';
                } else {
                    equalStatus.textContent = 'No ✗';
                    equalStatus.className = 'stat-value not-equal';
                }
            } else {
                document.getElementById('type1Count').textContent = 'Invalid';
                document.getElementById('type2Count').textContent = 'Invalid';
                document.getElementById('equalStatus').textContent = 'Invalid coloring';
                document.getElementById('equalStatus').className = 'stat-value';
            }
        }

        // Handle canvas click
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const allPoints = generateAllPoints(n);
            const cellSize = Math.min(450 / n, 80);
            const offsetX = 50;
            const offsetY = 450;

            for (const [h, k] of allPoints) {
                const x = offsetX + h * cellSize;
                const y = offsetY - k * cellSize;

                const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                if (dist < 15) {
                    const pointStr = JSON.stringify([h, k]);
                    if (bluePoints.has(pointStr)) {
                        bluePoints.delete(pointStr);
                    } else {
                        bluePoints.add(pointStr);
                    }
                    selectedColoringIndex = null;
                    drawGrid();
                    break;
                }
            }
        });

        // Handle n slider change
        nSlider.addEventListener('input', (e) => {
            n = parseInt(e.target.value);
            nValue.textContent = n;
            bluePoints.clear();
            validColorings = [];
            selectedColoringIndex = null;
            drawGrid();
            document.getElementById('coloringList').innerHTML = '';
            document.getElementById('simulationResults').textContent =
                'Click "Run Simulation" to enumerate all valid colorings and verify the conjecture.';
        });

        // Run simulation
        document.getElementById('runSimulation').addEventListener('click', () => {
            validColorings = enumerateValidColorings(n);

            const listDiv = document.getElementById('coloringList');
            listDiv.innerHTML = '';

            validColorings.forEach((coloring, index) => {
                const item = document.createElement('div');
                item.className = 'coloring-item' + (!coloring.equal ? ' counterexample' : '');
                item.innerHTML = `
                    <div><strong>Coloring ${index + 1}</strong></div>
                    <div>Blue points: ${coloring.blueSet.size}</div>
                    <div>Type 1: ${coloring.type1Count}, Type 2: ${coloring.type2Count}</div>
                    <div style="color: ${coloring.equal ? '#10b981' : '#ef4444'}">
                        ${coloring.equal ? '✓ Equal' : '✗ Not equal'}
                    </div>
                `;

                item.addEventListener('click', () => {
                    selectedColoringIndex = index;
                    bluePoints = new Set(coloring.blueSet);
                    drawGrid();

                    document.querySelectorAll('.coloring-item').forEach(el => {
                        el.classList.remove('selected');
                    });
                    item.classList.add('selected');
                });

                listDiv.appendChild(item);
            });

            const counterexamples = validColorings.filter(c => !c.equal);
            const resultsDiv = document.getElementById('simulationResults');
            resultsDiv.innerHTML = `
                <strong>Total valid colorings:</strong> ${validColorings.length}<br>
                <strong>Counterexamples found:</strong> ${counterexamples.length}<br>
                <strong>Conjecture holds:</strong> ${counterexamples.length === 0 ? '✓ Yes' : '✗ No'}
            `;
        });

        // Random coloring
        document.getElementById('randomColoring').addEventListener('click', () => {
            bluePoints.clear();
            const allPoints = generateAllPoints(n);

            // Randomly select points
            for (const point of allPoints) {
                if (Math.random() > 0.5) {
                    bluePoints.add(JSON.stringify(point));
                }
            }

            // Make it valid by removing violations
            let changed = true;
            while (changed) {
                changed = false;
                const redPoints = allPoints.filter(p => !bluePoints.has(JSON.stringify(p)));

                for (const [h, k] of redPoints) {
                    for (let hp = 0; hp <= h; hp++) {
                        for (let kp = 0; kp <= k; kp++) {
                            const pointStr = JSON.stringify([hp, kp]);
                            if (bluePoints.has(pointStr)) {
                                bluePoints.delete(pointStr);
                                changed = true;
                            }
                        }
                    }
                }
            }

            selectedColoringIndex = null;
            drawGrid();
        });

        // Clear coloring
        document.getElementById('clearColoring').addEventListener('click', () => {
            bluePoints.clear();
            selectedColoringIndex = null;
            drawGrid();
        });

        // Initialize
        drawGrid();
    </script>
</body>
</html>
