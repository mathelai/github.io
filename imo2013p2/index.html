<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMO 2013 P2 Simulation</title>
    <link rel="stylesheet" href="../tokens.css">
    <link rel="stylesheet" href="../base.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
    color-scheme: light dark;
            /* Light theme colors */
            --bg-primary: #F8FAFC;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #F1F5F9;
            --text-primary: #0F172A;
            --text-secondary: #64748B;
            --text-tertiary: #94A3B8;
            --border-primary: #E2E8F0;
            --border-secondary: #F1F5F9;
            --accent-primary: #7A9D8F;
            --accent-secondary: #9BB8AC;
            --accent-hover: #5A8070;
            --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            --shadow-md: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }
        [data-theme="dark"] {
            /* Dark theme colors */
            --bg-primary: #0F172A;
            --bg-secondary: #1E293B;
            --bg-tertiary: #334155;
            --text-primary: #F1F5F9;
            --text-secondary: #CBD5E1;
            --text-tertiary: #94A3B8;
            --border-primary: #334155;
            --border-secondary: #475569;
            --accent-primary: #7A9D8F;
            --accent-secondary: #9BB8AC;
            --accent-hover: #5A8070;
            --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 10px 15px -3px rgb(0 0 0 / 0.3);
        }
        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            overflow: hidden;
        }
        header {
            background: #F8FAFC;
            color: var(--text-primary);
            padding: 30px;
            text-align: center;
        }
        header h1 {
            font-size: 2.25rem;
            margin-bottom: 10px;
        }
        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            padding: 30px;
        }
        .section {
            background: #f7fafc;
            border-radius: 10px;
            padding: 25px;
            border: 1px solid #e2e8f0;
        }
        .section h2 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 1px solid #7A9D8F;
            padding-bottom: 10px;
        }
        .problem-statement {
            grid-column: 1 / -1;
            background: #edf2f7;
            border-left: 5px solid #5a67d8;
        }
        .problem-statement p {
            line-height: 1.8;
            color: #2d3748;
            font-size: 1.1em;
        }
        .problem-statement ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        .problem-statement li {
            margin: 8px 0;
            line-height: 1.6;
        }
        .answer-box {
            background: linear-gradient(135deg, #7A9D8F 0%, #9BB8AC 100%);
            box-shadow: 0 4px 12px rgba(122, 157, 143, 0.15);
            color: white;
            border: 2px solid #38a169;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        .answer-box h3 {
            color: #22543d;
            font-size: 1.8em;
            margin-bottom: 10px;
        }
        .answer-box .answer-value {
            font-size: 3em;
            font-weight: bold;
            color: #2f855a;
        }
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        canvas {
            border: 2px solid #cbd5e0;
            border-radius: 8px;
            background: var(--bg-secondary);
            cursor: crosshair;
            max-width: 100%;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .control-group label {
            font-weight: 600;
            color: #2d3748;
            min-width: 100px;
        }
        .control-group input[type="number"] {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #cbd5e0;
            border-radius: 5px;
            font-size: 1em;
        }
        .control-group input[type="range"] {
            flex: 1;
        }
        .control-group span {
            min-width: 40px;
            font-weight: bold;
            color: #5a67d8;
        }
        button {
            background: linear-gradient(135deg, #7A9D8F 0%, #9BB8AC 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius:  8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(90, 103, 216, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .data-table th,
        .data-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        .data-table th {
            background: #5a67d8;
            color: white;
            font-weight: 600;
        }
        .data-table tr:hover {
            background: #edf2f7;
        }
        .proof-section {
            margin: 15px 0;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 5px;
            border-left: 4px solid #5a67d8;
        }
        .proof-section h4 {
            color: #5a67d8;
            margin-bottom: 10px;
        }
        .proof-section ol {
            padding-left: 25px;
            line-height: 1.8;
        }
        .proof-section li {
            margin: 8px 0;
            color: #2d3748;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            font-size: 1.1em;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #2d3748;
        }
        .status-message {
            margin-top: 15px;
            padding: 12px;
            border-radius: 5px;
            text-align: center;
            font-weight: 600;
        }
        .status-message.info {
            background: #bee3f8;
            color: #2c5282;
        }
        .full-width {
            grid-column: 1 / -1;
        }
        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        .theme-icon {
            display: none;
        }
                /* Motion preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
    <main id="main">
  <div class="container">
        <header>
            <div class="header-wrapper">
                <h1>IMO 2013 Problem 2</h1>
                <p class="subtitle">Colombian Configuration</p>
            </div>
        </header>
        <div class="content">
            <!-- Problem Statement -->
            <div class="section problem-statement">
                <h2 id="problem-title">Problem Statement</h2>
                <p>
                    A configuration of 4027 points in the plane is called <strong>Colombian</strong> if it consists of
                    2013 red points and 2014 blue points, and no three of the points of the configuration are collinear.
                </p>
                <p style="margin-top: 15px;">
                    By drawing some lines, the plane is divided into several regions. An arrangement of lines is
                    <strong>good</strong> for a Colombian configuration if the following two conditions are satisfied:
                </p>
                <ul>
                    <li>no line passes through any point of the configuration;</li>
                    <li>no region contains points of both colours.</li>
                </ul>
                <p style="margin-top: 15px;">
                    <strong>Find the least value of k such that for any Colombian configuration of 4027 points,
                    there is a good arrangement of k lines.</strong>
                </p>
                <div class="answer-box">
                    <h3>Answer</h3>
                    <div class="answer-value">k = 2013</div>
                    <p style="margin-top: 10px; color: #2d3748;">
                        The minimum number of lines needed is equal to min(red points, blue points) = min(2013, 2014) = 2013
                    </p>
                </div>
            </div>
            <!-- Interactive Visualization -->
            <div class="section">
                <h2>Interactive Visualization</h2>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #e53e3e;"></div>
                        <span>Red Points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #3182ce;"></div>
                        <span>Blue Points</span>
                    </div>
                </div>
                <div class="canvas-container">
                    <canvas id="mainCanvas" width="500" height="500"></canvas>
                </div>
                <div class="controls">
                    <div class="control-group">
                        <label>Red Points:</label>
                        <input type="range" id="redSlider" min="1" max="50" value="10">
                        <span id="redValue">10</span>
                    </div>
                    <div class="control-group">
                        <label>Blue Points:</label>
                        <input type="range" id="blueSlider" min="1" max="50" value="11">
                        <span id="blueValue">11</span>
                    </div>
                    <button onclick="generateNewConfiguration()">Generate New Configuration</button>
                    <button onclick="showSeparatingLines()">Show Separating Lines</button>
                    <button onclick="clearLines()">Clear Lines</button>
                </div>
                <div class="status-message info" id="statusMessage">
                    Click "Generate New Configuration" to start
                </div>
            </div>
            <!-- Small Cases Analysis -->
            <div class="section">
                <h2>Pattern Discovery - Small Cases</h2>
                <table class="data-table" id="smallCasesTable">
                    <thead>
                        <tr>
                            <th>Red Points</th>
                            <th>Blue Points</th>
                            <th>Total</th>
                            <th>Min Lines (k)</th>
                        </tr>
                    </thead>
                    <tbody id="smallCasesBody">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
                <div style="margin-top: 15px; padding: 15px; background: var(--bg-secondary); border-radius: 5px;">
                    <strong>Pattern:</strong> k = min(red points, blue points)
                </div>
            </div>
            <!-- Proof Sketches -->
            <div class="section full-width">
                <h2>Mathematical Proof</h2>
                <div class="proof-section">
                    <h4>Upper Bound: 2013 lines are sufficient</h4>
                    <ol>
                        <li>For each of the 2013 red points r<sub>i</sub>, we construct a line L<sub>i</sub> that separates r<sub>i</sub> from all blue points.</li>
                        <li>This is possible because no three points are collinear.</li>
                        <li>For each red point r<sub>i</sub>, consider the 2014 blue points.</li>
                        <li>We can draw a line that has r<sub>i</sub> on one side and all 2014 blue points on the other side.</li>
                        <li>After drawing all 2013 such lines, each region contains at most red points (no blue points mixed with red).</li>
                        <li><strong>Therefore, 2013 lines suffice.</strong></li>
                    </ol>
                </div>
                <div class="proof-section">
                    <h4>Lower Bound: At least 2013 lines are necessary</h4>
                    <ol>
                        <li>Consider a configuration where red and blue points are "maximally mixed".</li>
                        <li>Place points on two concentric circles: red points on the inner circle, blue points on the outer circle.</li>
                        <li>In this configuration, we need to separate each red point from the blue points surrounding it.</li>
                        <li>Each line divides the plane into two half-planes. A line can "resolve" at most one red point by separating it from all blue points.</li>
                        <li>Since we have 2013 red points, and each line can resolve at most one red point in the worst case, we need at least 2013 lines.</li>
                        <li><strong>Therefore, k ≥ 2013.</strong></li>
                    </ol>
                </div>
                <div style="margin-top: 20px; padding: 20px; background: #fef5e7; border-radius: 8px; border: 2px solid #f39c12;">
                    <h4 style="color: #d68910; margin-bottom: 10px;">Key Insight</h4>
                    <p style="color: #2d3748; line-height: 1.8;">
                        The answer is determined by the <strong>minority color</strong>. With 2013 red points and 2014 blue points,
                        we need exactly <strong>2013 lines</strong> in the worst case. Each line can separate at most one point of
                        the minority color from all points of the majority color. This general principle applies to any configuration:
                        <strong>k = min(number of red points, number of blue points)</strong>.
                    </p>
                </div>
            </div>
        </div>
    </div>
    </main>
  <script>
        // Embedded results data (generated from simulation)
        const resultsData = {
            "problem_statement": {
                "description": "Colombian configuration with 2013 red and 2014 blue points",
                "question": "Find the least value of k such that for any Colombian configuration, there is a good arrangement of k lines"
            },
            "answer": 2013,
            "small_cases": [
                {"num_red": 1, "num_blue": 2, "total_points": 3, "theoretical_minimum": 1},
                {"num_red": 2, "num_blue": 3, "total_points": 5, "theoretical_minimum": 2},
                {"num_red": 3, "num_blue": 4, "total_points": 7, "theoretical_minimum": 3},
                {"num_red": 4, "num_blue": 5, "total_points": 9, "theoretical_minimum": 4},
                {"num_red": 5, "num_blue": 6, "total_points": 11, "theoretical_minimum": 5},
                {"num_red": 10, "num_blue": 11, "total_points": 21, "theoretical_minimum": 10},
                {"num_red": 20, "num_blue": 21, "total_points": 41, "theoretical_minimum": 20},
                {"num_red": 2013, "num_blue": 2014, "total_points": 4027, "theoretical_minimum": 2013}
            ]
        };
        // Canvas and visualization state
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        let redPoints = [];
        let bluePoints = [];
        let separatingLines = [];
        // Initialize
        window.addEventListener('load', function() {
            populateSmallCasesTable();
            generateNewConfiguration();
        });
        // Populate small cases table
        function populateSmallCasesTable() {
            const tbody = document.getElementById('smallCasesBody');
            tbody.innerHTML = '';
            resultsData.small_cases.forEach(caseData => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${caseData.num_red}</td>
                    <td>${caseData.num_blue}</td>
                    <td>${caseData.total_points}</td>
                    <td><strong style="color: #5a67d8;">${caseData.theoretical_minimum}</strong></td>
                `;
                tbody.appendChild(row);
            });
        }
        // Update slider values
        document.getElementById('redSlider').addEventListener('input', function(e) {
            document.getElementById('redValue').textContent = e.target.value;
        });
        document.getElementById('blueSlider').addEventListener('input', function(e) {
            document.getElementById('blueValue').textContent = e.target.value;
        });
        // Generate random points ensuring no three are collinear
        function generateRandomPoints(count, existingPoints = []) {
            const points = [];
            const maxAttempts = 1000;
            for (let i = 0; i < count; i++) {
                let attempt = 0;
                let point;
                do {
                    // Generate point with grid-based approach to avoid collinearity
                    const baseX = (Math.random() * 450) + 25;
                    const baseY = (Math.random() * 450) + 25;
                    const offsetX = (Math.random() - 0.5) * 5;
                    const offsetY = (Math.random() - 0.5) * 5;
                    point = {
                        x: baseX + offsetX,
                        y: baseY + offsetY
                    };
                    attempt++;
                } while (isCollinear(point, [...existingPoints, ...points]) && attempt < maxAttempts);
                points.push(point);
            }
            return points;
        }
        // Check if adding a point creates collinearity
        function isCollinear(point, existingPoints, tolerance = 0.1) {
            if (existingPoints.length < 2) return false;
            for (let i = 0; i < existingPoints.length; i++) {
                for (let j = i + 1; j < existingPoints.length; j++) {
                    const p1 = existingPoints[i];
                    const p2 = existingPoints[j];
                    // Cross product to check collinearity
                    const cross = (p2.x - p1.x) * (point.y - p1.y) - (p2.y - p1.y) * (point.x - p1.x);
                    if (Math.abs(cross) < tolerance) {
                        return true;
                    }
                }
            }
            return false;
        }
        // Generate new configuration
        function generateNewConfiguration() {
            const numRed = parseInt(document.getElementById('redSlider').value);
            const numBlue = parseInt(document.getElementById('blueSlider').value);
            redPoints = generateRandomPoints(numRed);
            bluePoints = generateRandomPoints(numBlue, redPoints);
            separatingLines = [];
            drawCanvas();
            const minLines = Math.min(numRed, numBlue);
            document.getElementById('statusMessage').innerHTML =
                `Configuration generated: ${numRed} red, ${numBlue} blue points<br>` +
                `Minimum lines needed: <strong>${minLines}</strong>`;
        }
        // Draw the canvas
        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw separating lines
            ctx.strokeStyle = '#48bb78';
            ctx.lineWidth = 2;
            separatingLines.forEach(line => {
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
            });
            ctx.setLineDash([]);
            // Draw blue points
            bluePoints.forEach(point => {
                ctx.fillStyle = '#3182ce';
                ctx.strokeStyle = '#2c5282';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });
            // Draw red points
            redPoints.forEach(point => {
                ctx.fillStyle = '#e53e3e';
                ctx.strokeStyle = '#9b2c2c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            });
        }
        // Show separating lines
        function showSeparatingLines() {
            separatingLines = [];
            // For each red point, create a line that separates it from all blue points
            redPoints.forEach((redPoint, index) => {
                if (bluePoints.length === 0) return;
                // Find a line that separates this red point from all blue points
                // Use a simple approach: find the centroid of blue points and draw a perpendicular bisector
                const blueCentroidX = bluePoints.reduce((sum, p) => sum + p.x, 0) / bluePoints.length;
                const blueCentroidY = bluePoints.reduce((sum, p) => sum + p.y, 0) / bluePoints.length;
                // Direction from blue centroid to red point
                const dx = redPoint.x - blueCentroidX;
                const dy = redPoint.y - blueCentroidY;
                // Midpoint
                const midX = (redPoint.x + blueCentroidX) / 2;
                const midY = (redPoint.y + blueCentroidY) / 2;
                // Perpendicular direction
                const perpDx = -dy;
                const perpDy = dx;
                // Normalize and extend
                const length = Math.sqrt(perpDx * perpDx + perpDy * perpDy);
                const normDx = (perpDx / length) * 500;
                const normDy = (perpDy / length) * 500;
                separatingLines.push({
                    x1: midX - normDx,
                    y1: midY - normDy,
                    x2: midX + normDx,
                    y2: midY + normDy
                });
            });
            drawCanvas();
            document.getElementById('statusMessage').innerHTML =
                `Showing ${separatingLines.length} separating lines<br>` +
                `Each line separates one red point from all blue points`;
        }
        // Clear lines
        function clearLines() {
            separatingLines = [];
            drawCanvas();
            const numRed = redPoints.length;
            const numBlue = bluePoints.length;
            const minLines = Math.min(numRed, numBlue);
            document.getElementById('statusMessage').innerHTML =
                `Lines cleared. Current configuration needs ${minLines} lines minimum.`;
        }
        </script>
</body>
</html>
