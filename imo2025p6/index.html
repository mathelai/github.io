<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMO 2025 P6 Simulation</title>
    <link rel="stylesheet" href="../tokens.css">
    <link rel="stylesheet" href="../base.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        :root {
    color-scheme: light dark;
            /* Light theme colors */
            --bg-primary: #F8FAFC;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #F1F5F9;
            --text-primary: #0F172A;
            --text-secondary: #64748B;
            --text-tertiary: #94A3B8;
            --border-primary: #E2E8F0;
            --border-secondary: #F1F5F9;
            --accent-primary: #7A9D8F;
            --accent-secondary: #9BB8AC;
            --accent-hover: #5A8070;
            --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            --shadow-md: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }
        [data-theme="dark"] {
            /* Dark theme colors */
            --bg-primary: #0F172A;
            --bg-secondary: #1E293B;
            --bg-tertiary: #334155;
            --text-primary: #F1F5F9;
            --text-secondary: #CBD5E1;
            --text-tertiary: #94A3B8;
            --border-primary: #334155;
            --border-secondary: #475569;
            --accent-primary: #7A9D8F;
            --accent-secondary: #9BB8AC;
            --accent-hover: #5A8070;
            --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 10px 15px -3px rgb(0 0 0 / 0.3);
        }
        body {
            font-family: var(--font-family);
            background: var(--bg-primary);
            padding: 20px;
            min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            overflow: hidden;
        }
        header {
            background: #F8FAFC;
            color: var(--text-primary);
            padding: 30px;
            text-align: center;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .problem-statement {
            background: var(--bg-tertiary);
            padding: 25px;
            margin: 20px;
            border-radius: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            border-left: 5px solid #7A9D8F;
        }
        .problem-statement h2 {
            color: #7A9D8F;
            margin-bottom: 15px;
        }
        .problem-text {
            background: var(--bg-tertiary);
            padding: 24px;
            border-left: 4px solid #7A9D8F;
            border-radius: 12px;
            font-size: 1.05em;
            line-height: 1.7;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }
        /* Override for old problem-text */
        .old-problem-text {
            line-height: 1.8;
            color: var(--text-primary);
            font-size: 1.1em;
        }
        .controls {
            padding: 25px;
            background: var(--bg-secondary);
            border-bottom: 2px solid #e9ecef;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        input[type="range"] {
            flex: 1;
            min-width: 200px;
            height: 8px;
            border-radius: 5px;
            background: #e9ecef;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #7A9D8F;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #7A9D8F;
            cursor: pointer;
            border: none;
        }
        .size-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #7A9D8F;
            min-width: 60px;
        }
        select, button {
            padding: 10px 20px;
            border: 2px solid #7A9D8F;
            border-radius:  8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        select {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        button {
            background: #7A9D8F;
            color: white;
            font-weight: 600;
        }
        button:hover {
            background: #5A8070;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 25px;
        }
        .visualization {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #gridCanvas {
            border: 2px solid #dee2e6;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            background: var(--bg-secondary);
        }
        .info-panel {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            max-height: 600px;
        }
        .info-section {
            margin-bottom: 25px;
        }
        .info-section h3 {
            color: #7A9D8F;
            margin-bottom: 12px;
            border-bottom: 2px solid #7A9D8F;
            padding-bottom: 8px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }
        .stat-label {
            font-weight: 600;
            color: var(--text-primary);
        }
        .stat-value {
            color: #7A9D8F;
            font-weight: bold;
        }
        .tile-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }
        .tile-item {
            padding: 5px;
            border-bottom: 1px solid #e9ecef;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 2px solid #333;
        }
        .answer-box {
            background: linear-gradient(135deg, #7A9D8F 0%, #9BB8AC 100%);
            box-shadow: 0 4px 12px rgba(122, 157, 143, 0.15);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px;
            text-align: center;
        }
        .answer-box h2 {
            font-size: 1.8em;
            margin-bottom: 10px;
        }
        .answer-value {
            font-size: 3em;
            font-weight: bold;
            margin: 15px 0;
        }
        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
        .theme-icon {
            display: none;
        }
                /* Motion preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
    <main id="main">
  <div class="container">
        <header>
            <div class="header-wrapper">
                <h1>IMO 2025 Problem 6</h1>
                <p class="subtitle">Matilda Tiling</p>
            </div>
        </header>
        <section aria-labelledby="problem-title">
  <div class="problem-statement">
            <h2 id="problem-title">Problem Statement</h2>
            <p class="problem-text">
                Consider a 2025 × 2025 grid of unit squares. Matilda wishes to place on the grid some rectangular tiles,
                possibly of different sizes, such that each side of every tile lies on a grid line and every unit square
                is covered by at most one tile.
            </p>
            <br>
            <p class="problem-text">
                <strong>Determine the minimum number of tiles Matilda needs to place so that each row and each column
                of the grid has exactly one unit square that is not covered by any tile.</strong>
            </p>
        </div>
        <div class="answer-box">
            <h2>Answer for 2025 × 2025 Grid</h2>
            <div class="answer-value">4048</div>
            <p>Formula: 2n - 2 = 2(2025) - 2 = 4048 tiles</p>
        </div>
        <div class="controls">
            <div class="control-group">
                <label>Grid Size: <span class="size-value" id="sizeValue">5</span> × <span class="size-value" id="sizeValue2">5</span></label>
                <div class="control-row">
                    <input type="range" id="gridSize" min="2" max="20" value="5">
                </div>
            </div>
            <div class="control-group">
                <label>Strategy:</label>
                <div class="control-row">
                    <select id="strategy">
                        <option value="diagonal_vertical">Diagonal - Vertical Tiles</option>
                        <option value="diagonal_horizontal">Diagonal - Horizontal Tiles</option>
                        <option value="anti_diagonal">Anti-Diagonal</option>
                        <option value="custom">Custom Pattern</option>
                    </select>
                    <button onclick="generateTiles()">Generate Tiles</button>
                    <button onclick="clearGrid()">Clear Grid</button>
                </div>
            </div>
        </div>
        <div class="content">
            <div class="visualization">
                <canvas id="gridCanvas" width="600" height="600"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #fff;"></div>
                        <span>Uncovered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffd93d;"></div>
                        <span>Uncovered (Target)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: rgba(102, 126, 234, 0.6);"></div>
                        <span>Covered by Tile</span>
                    </div>
                </div>
            </div>
            <div class="info-panel">
                <div class="info-section">
                    <h3>Statistics</h3>
                    <div class="stat-item">
                        <span class="stat-label">Grid Size:</span>
                        <span class="stat-value" id="statGridSize">5 × 5</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Squares:</span>
                        <span class="stat-value" id="statTotalSquares">25</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Uncovered Squares:</span>
                        <span class="stat-value" id="statUncovered">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Covered Squares:</span>
                        <span class="stat-value" id="statCovered">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Number of Tiles:</span>
                        <span class="stat-value" id="statTileCount">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Minimum Possible:</span>
                        <span class="stat-value" id="statMinimum">8</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Valid Solution:</span>
                        <span class="stat-value" id="statValid">No</span>
                    </div>
                </div>
                <div class="info-section">
                    <h3>Pattern Analysis</h3>
                    <div id="patternInfo"></div>
                </div>
                <div class="info-section">
                    <h3>Tiles Placed</h3>
                    <div class="tile-list" id="tileList">
                        <em>No tiles placed yet</em>
                    </div>
                </div>
                <div class="info-section">
                    <h3>Theory</h3>
                    <p style="line-height: 1.6; color: var(--text-primary);">
                        For an n×n grid with exactly one uncovered square per row and column,
                        the minimum number of tiles is <strong>2n - 2</strong>.
                        <br><br>
                        This is achieved by choosing uncovered squares along the main diagonal
                        and using vertical (or horizontal) tiles to cover the remaining squares.
                    </p>
                </div>
            </div>
        </div>
    </div>
    </main>
  <script>
        // State
        let gridSize = 5;
        let tiles = [];
        let grid = [];
        let uncoveredTarget = [];
        // Canvas setup
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        // Initialize
        function init() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            updateSizeDisplay();
            resetGrid();
            generateTiles();
        }
        function updateSizeDisplay() {
            document.getElementById('sizeValue').textContent = gridSize;
            document.getElementById('sizeValue2').textContent = gridSize;
        }
        function resetGrid() {
            grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            tiles = [];
            uncoveredTarget = [];
        }
        function clearGrid() {
            resetGrid();
            updateDisplay();
        }
        function generateTiles() {
            resetGrid();
            const strategy = document.getElementById('strategy').value;
            switch(strategy) {
                case 'diagonal_vertical':
                    generateDiagonalVertical();
                    break;
                case 'diagonal_horizontal':
                    generateDiagonalHorizontal();
                    break;
                case 'anti_diagonal':
                    generateAntiDiagonal();
                    break;
                case 'custom':
                    generateCustom();
                    break;
            }
            updateDisplay();
        }
        function generateDiagonalVertical() {
            // Leave diagonal uncovered: (i, i) for each i
            for (let i = 0; i < gridSize; i++) {
                uncoveredTarget.push([i, i]);
            }
            // Place vertical tiles in each column, skipping diagonal
            for (let col = 0; col < gridSize; col++) {
                const diagRow = col;
                // Above diagonal
                if (diagRow > 0) {
                    placeTile(0, col, diagRow, 1);
                }
                // Below diagonal
                if (diagRow < gridSize - 1) {
                    placeTile(diagRow + 1, col, gridSize - diagRow - 1, 1);
                }
            }
        }
        function generateDiagonalHorizontal() {
            // Leave diagonal uncovered: (i, i) for each i
            for (let i = 0; i < gridSize; i++) {
                uncoveredTarget.push([i, i]);
            }
            // Place horizontal tiles in each row, skipping diagonal
            for (let row = 0; row < gridSize; row++) {
                const diagCol = row;
                // Left of diagonal
                if (diagCol > 0) {
                    placeTile(row, 0, 1, diagCol);
                }
                // Right of diagonal
                if (diagCol < gridSize - 1) {
                    placeTile(row, diagCol + 1, 1, gridSize - diagCol - 1);
                }
            }
        }
        function generateAntiDiagonal() {
            // Leave anti-diagonal uncovered: (i, n-1-i) for each i
            for (let i = 0; i < gridSize; i++) {
                uncoveredTarget.push([i, gridSize - 1 - i]);
            }
            // Place horizontal tiles in each row, skipping anti-diagonal
            for (let row = 0; row < gridSize; row++) {
                const uncovCol = gridSize - 1 - row;
                // Left of uncovered
                if (uncovCol > 0) {
                    placeTile(row, 0, 1, uncovCol);
                }
                // Right of uncovered
                if (uncovCol < gridSize - 1) {
                    placeTile(row, uncovCol + 1, 1, gridSize - uncovCol - 1);
                }
            }
        }
        function generateCustom() {
            // Random permutation pattern
            let cols = Array.from({length: gridSize}, (_, i) => i);
            // Shuffle
            for (let i = cols.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [cols[i], cols[j]] = [cols[j], cols[i]];
            }
            for (let row = 0; row < gridSize; row++) {
                uncoveredTarget.push([row, cols[row]]);
            }
            // Place horizontal tiles
            for (let row = 0; row < gridSize; row++) {
                const uncovCol = cols[row];
                if (uncovCol > 0) {
                    placeTile(row, 0, 1, uncovCol);
                }
                if (uncovCol < gridSize - 1) {
                    placeTile(row, uncovCol + 1, 1, gridSize - uncovCol - 1);
                }
            }
        }
        function placeTile(row, col, height, width) {
            // Mark grid cells as covered
            for (let r = row; r < row + height; r++) {
                for (let c = col; c < col + width; c++) {
                    if (r < gridSize && c < gridSize) {
                        grid[r][c] = true;
                    }
                }
            }
            // Add to tiles list
            tiles.push({row, col, height, width});
        }
        function checkValidity() {
            // Count uncovered squares per row and column
            const rowCounts = Array(gridSize).fill(0);
            const colCounts = Array(gridSize).fill(0);
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (!grid[r][c]) {
                        rowCounts[r]++;
                        colCounts[c]++;
                    }
                }
            }
            // Check if all rows and columns have exactly 1 uncovered square
            return rowCounts.every(c => c === 1) && colCounts.every(c => c === 1);
        }
        function updateDisplay() {
            drawGrid();
            updateStats();
        }
        function drawGrid() {
            const cellSize = Math.min(600 / gridSize, 50);
            const totalSize = cellSize * gridSize;
            canvas.width = totalSize;
            canvas.height = totalSize;
            // Draw grid background
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Draw tiles
            const colors = generateColors(tiles.length);
            tiles.forEach((tile, index) => {
                ctx.fillStyle = colors[index];
                ctx.fillRect(
                    tile.col * cellSize,
                    tile.row * cellSize,
                    tile.width * cellSize,
                    tile.height * cellSize
                );
            });
            // Highlight target uncovered squares
            ctx.fillStyle = '#ffd93d';
            uncoveredTarget.forEach(([row, col]) => {
                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
            });
            // Draw grid lines
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= gridSize; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, totalSize);
                ctx.stroke();
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(totalSize, i * cellSize);
                ctx.stroke();
            }
            // Draw tile borders more prominently
            ctx.strokeStyle = '#9BB8AC';
            ctx.lineWidth = 2;
            tiles.forEach(tile => {
                ctx.strokeRect(
                    tile.col * cellSize,
                    tile.row * cellSize,
                    tile.width * cellSize,
                    tile.height * cellSize
                );
            });
        }
        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsla(${hue}, 60%, 70%, 0.6)`);
            }
            return colors;
        }
        function updateStats() {
            const totalSquares = gridSize * gridSize;
            let uncoveredCount = 0;
            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (!grid[r][c]) uncoveredCount++;
                }
            }
            const coveredCount = totalSquares - uncoveredCount;
            const isValid = checkValidity();
            const minimum = 2 * gridSize - 2;
            document.getElementById('statGridSize').textContent = `${gridSize} × ${gridSize}`;
            document.getElementById('statTotalSquares').textContent = totalSquares;
            document.getElementById('statUncovered').textContent = uncoveredCount;
            document.getElementById('statCovered').textContent = coveredCount;
            document.getElementById('statTileCount').textContent = tiles.length;
            document.getElementById('statMinimum').textContent = minimum;
            document.getElementById('statValid').textContent = isValid ? 'Yes ✓' : 'No ✗';
            document.getElementById('statValid').style.color = isValid ? '#28a745' : '#dc3545';
            // Update tile list
            const tileListHtml = tiles.map((tile, i) =>
                `<div class="tile-item">Tile ${i+1}: (${tile.row},${tile.col}) size ${tile.height}×${tile.width}</div>`
            ).join('');
            document.getElementById('tileList').innerHTML = tileListHtml || '<em>No tiles placed</em>';
            // Update pattern info
            const patternHtml = `
                <div class="stat-item">
                    <span class="stat-label">Formula:</span>
                    <span class="stat-value">2n - 2</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">For n=${gridSize}:</span>
                    <span class="stat-value">2(${gridSize}) - 2 = ${minimum}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Current tiles:</span>
                    <span class="stat-value">${tiles.length}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Optimal:</span>
                    <span class="stat-value">${tiles.length === minimum ? 'Yes ✓' : 'No'}</span>
                </div>
            `;
            document.getElementById('patternInfo').innerHTML = patternHtml;
        }
        // Event listeners
        document.getElementById('gridSize').addEventListener('input', function(e) {
            gridSize = parseInt(e.target.value);
            updateSizeDisplay();
            init();
        });
        // Initialize on load
        init();
        </script>
</body>
</html>
