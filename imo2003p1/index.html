<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMO 2003 P1 Simulation</title>
    <link rel="stylesheet" href="../tokens.css">
    <link rel="stylesheet" href="../base.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .problem-statement {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            margin-top: 20px;
            border-radius: 10px;
            line-height: 1.8;
            text-align: left;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }

        input[type="number"] {
            width: 150px;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 16px;
            margin-right: 15px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .visualization {
            padding: 30px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        .canvas-container {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        .legend {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }

        .explanation {
            margin-top: 30px;
            padding: 20px;
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            border-radius: 5px;
        }

        .explanation h3 {
            color: #1976D2;
            margin-bottom: 10px;
        }

        .algorithm-select {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 16px;
            margin-right: 15px;
            background: white;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #c62828;
        }

        .success {
            background: #e8f5e9;
            color: #2e7d32;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #2e7d32;
        }
            /* Motion preferences */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        </style>
</head>
<body>
  <a class="skip-link" href="#main">Skip to content</a>
    <main id="main">
  <div class="container">
        <header>
            <h1>IMO 2003 Problem 1</h1>
            <section aria-labelledby="problem-title">
  <div class="problem-statement">
                <strong>Problem:</strong> S is the set {1, 2, 3, ..., 1000000}. Show that for any subset A of S
                with 101 elements we can find 100 distinct elements x<sub>i</sub> of S, such that the sets
                {a + x<sub>i</sub> | a ∈ A} are all pairwise disjoint.
            </div>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>Set Size (S = {1, ..., S_max})</label>
                <input type="number" id="sMax" value="100" min="10" max="1000">
            </div>
            <div class="control-group">
                <label>Subset Size (|A|)</label>
                <input type="number" id="aSize" value="11" min="2" max="100">
            </div>
            <div class="control-group">
                <label>Number of Offsets to Find</label>
                <input type="number" id="numOffsets" value="10" min="1" max="100">
            </div>
            <div class="control-group">
                <label>Algorithm</label>
                <select id="algorithm" class="algorithm-select">
                    <option value="optimal">Optimal (Spacing = max(A) - min(A) + 1)</option>
                    <option value="greedy">Greedy Search</option>
                </select>
            </div>
            <button onclick="runSimulation()">Run Simulation</button>
            <button onclick="generateRandom()">Generate Random A</button>
        </div>

        <div class="visualization">
            <div id="message"></div>

            <div class="stats" role="status" aria-live="polite">
                <div class="stat-card">
                    <h3>Set A Size</h3>
                    <div class="value" id="statASize">0</div>
                </div>
                <div class="stat-card">
                    <h3>Offsets Found</h3>
                    <div class="value" id="statOffsets">0</div>
                </div>
                <div class="stat-card">
                    <h3>A Range</h3>
                    <div class="value" id="statRange">0</div>
                </div>
                <div class="stat-card">
                    <h3>Spacing Used</h3>
                    <div class="value" id="statSpacing">0</div>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="canvas" role="img" aria-label="Interactive visualization of the mathematical problem"></canvas>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #2196F3;"></div>
                    <span>Original Set A</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4CAF50;"></div>
                    <span>A + x₁</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF9800;"></div>
                    <span>A + x₂</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #E91E63;"></div>
                    <span>A + x₃</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9C27B0;"></div>
                    <span>A + x₄+</span>
                </div>
            </div>

            <div class="explanation">
                <h3>Key Insight</h3>
                <p>
                    The optimal algorithm uses offsets spaced by <strong>spacing = max(A) - min(A) + 1</strong>.
                    This ensures that the maximum element of A + k·spacing is strictly less than the minimum
                    element of A + (k+1)·spacing, guaranteeing pairwise disjoint sets.
                </p>
                <p style="margin-top: 10px;">
                    For the original problem with |A| = 101 and S_max = 1,000,000, this construction always works
                    since the span of A is at most 1,000,000, and we need 100 offsets, requiring values up to
                    approximately 100,000,000, which poses no theoretical limitation.
                </p>
            </div>
        </div>
    </div>

    </main>
  <script>
        let currentA = [];
        const colors = ['#2196F3', '#4CAF50', '#FF9800', '#E91E63', '#9C27B0', '#00BCD4', '#FFEB3B', '#795548'];

        function generateRandomSet(sMax, aSize) {
            const set = new Set();
            while (set.size < aSize) {
                set.add(Math.floor(Math.random() * sMax) + 1);
            }
            return Array.from(set).sort((a, b) => a - b);
        }

        function generateRandom() {
            const sMax = parseInt(document.getElementById('sMax').value);
            const aSize = parseInt(document.getElementById('aSize').value);
            currentA = generateRandomSet(sMax, aSize);
            showMessage(`Generated random set A: [${currentA.join(', ')}]`, 'success');
        }

        function findDisjointOffsetsOptimal(A, numOffsets) {
            const minA = Math.min(...A);
            const maxA = Math.max(...A);
            const spacing = maxA - minA + 1;

            const offsets = [];
            for (let k = 0; k < numOffsets; k++) {
                offsets.push(k * spacing);
            }

            return { offsets, spacing };
        }

        function findDisjointOffsetsGreedy(A, sMax, numOffsets) {
            const offsets = [];
            const usedValues = new Set();

            for (let i = 0; i < numOffsets; i++) {
                let found = false;
                for (let x = 0; x < sMax * 10; x++) {
                    if (offsets.includes(x)) continue;

                    const newSet = A.map(a => a + x);
                    const hasConflict = newSet.some(val => usedValues.has(val));

                    if (!hasConflict) {
                        offsets.push(x);
                        newSet.forEach(val => usedValues.add(val));
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return null;
                }
            }

            return { offsets, spacing: offsets.length > 1 ? offsets[1] - offsets[0] : 0 };
        }

        function showMessage(msg, type = 'success') {
            const messageDiv = document.getElementById('message');
            messageDiv.className = type;
            messageDiv.textContent = msg;
        }

        function runSimulation() {
            const sMax = parseInt(document.getElementById('sMax').value);
            const aSize = parseInt(document.getElementById('aSize').value);
            const numOffsets = parseInt(document.getElementById('numOffsets').value);
            const algorithm = document.getElementById('algorithm').value;

            if (currentA.length === 0 || currentA.length !== aSize) {
                currentA = generateRandomSet(sMax, aSize);
            }

            let result;
            if (algorithm === 'optimal') {
                result = findDisjointOffsetsOptimal(currentA, numOffsets);
            } else {
                result = findDisjointOffsetsGreedy(currentA, sMax, numOffsets);
            }

            if (!result || !result.offsets) {
                showMessage(`Failed to find ${numOffsets} disjoint offsets using ${algorithm} algorithm!`, 'error');
                return;
            }

            const { offsets, spacing } = result;

            // Update stats
            document.getElementById('statASize').textContent = currentA.length;
            document.getElementById('statOffsets').textContent = offsets.length;
            document.getElementById('statRange').textContent = Math.max(...currentA) - Math.min(...currentA);
            document.getElementById('statSpacing').textContent = spacing;

            showMessage(`Successfully found ${offsets.length} disjoint offsets! Offsets: [${offsets.slice(0, 10).join(', ')}${offsets.length > 10 ? '...' : ''}]`, 'success');

            // Visualize
            visualize(currentA, offsets);
        }

        function visualize(A, offsets) {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Calculate canvas dimensions
            const allSets = [A, ...offsets.map(x => A.map(a => a + x))];
            const allValues = allSets.flat();
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);

            const rowHeight = 40;
            const padding = 60;
            const width = Math.min(1200, Math.max(800, (maxVal - minVal + 1) * 2));
            const height = (offsets.length + 2) * rowHeight + 2 * padding;

            canvas.width = width;
            canvas.height = height;

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            // Calculate scale
            const scale = (width - 2 * padding) / (maxVal - minVal + 1);

            // Draw original set A
            drawSet(ctx, A, 0, minVal, scale, padding, rowHeight, colors[0], 'A');

            // Draw translated sets
            offsets.forEach((offset, idx) => {
                const translatedSet = A.map(a => a + offset);
                drawSet(ctx, translatedSet, idx + 1, minVal, scale, padding, rowHeight,
                       colors[(idx + 1) % colors.length], `A + ${offset}`);
            });

            // Draw axis
            drawAxis(ctx, minVal, maxVal, width, height, padding);
        }

        function drawSet(ctx, set, row, minVal, scale, padding, rowHeight, color, label) {
            const y = padding + row * rowHeight;

            // Draw label
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(label, padding - 10, y + 5);

            // Draw elements
            set.forEach(val => {
                const x = padding + (val - minVal) * scale;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw range line
            const minX = padding + (Math.min(...set) - minVal) * scale;
            const maxX = padding + (Math.max(...set) - minVal) * scale;
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(minX, y);
            ctx.lineTo(maxX, y);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawAxis(ctx, minVal, maxVal, width, height, padding) {
            const y = height - padding + 20;

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(width - padding, y);
            ctx.stroke();

            // Draw tick marks
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';

            const step = Math.ceil((maxVal - minVal) / 10);
            for (let val = minVal; val <= maxVal; val += step) {
                const x = padding + (val - minVal) * ((width - 2 * padding) / (maxVal - minVal + 1));
                ctx.beginPath();
                ctx.moveTo(x, y - 5);
                ctx.lineTo(x, y + 5);
                ctx.stroke();
                ctx.fillText(val.toString(), x, y + 20);
            }
        }

        // Initialize with a random set
        window.onload = function() {
            generateRandom();
        };
    </script>
</body>
</html>
